module HtmlApiGenerator

open FSharp.Text.TypedTemplateProvider
open MdnScrape

let [<Literal>] HtmlApiTemplate = """
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto generated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Vide

open System.Runtime.CompilerServices
open Browser.Types
open Vide

module HtmlElementBuilders =
    {{for elem in elements}}
    type {{elem.builderName}}{{elem.typeParams}}({{elem.ctorParams}}) =
        inherit {{elem.inheritorName}}<{{elem.inheritorGenTypParam}}>({{elem.ctorBaseArgs}})
    {{end}}

open HtmlElementBuilders

{{for elem in elements}}
[<Extension>]
type {{elem.builderName}}Extensions =
    class
        {{for attr in elem.attributes}}
        [<Extension>]
        static member {{attr.memberName}}(this: #{{elem.builderName}}{{if elem.hasGenArgs}}<_>{{end}}, value: {{attr.typ}}) =
            this.OnEval(fun x -> x.setAttribute("{{attr.name}}", value{{attr.toString}}))       {{end}}
        {{for evt in elem.events}}
        [<Extension>]
        static member {{evt.name}}(this: #{{elem.builderName}}{{if elem.hasGenArgs}}<_>{{end}}, handler) =
            this.OnInit(fun x -> x.{{evt.name}} <- (fun evt -> handler x evt))       {{end}}
    end
{{end}}

type Html =
    {{for elem in elements}}
    {{if elem.isHtmlElement}}static member inline {{elem.fsharpTageName}} = HtmlElementBuilders.{{elem.builderName}}(){{end}}
    {{end}}
"""

type Api = Template<HtmlApiTemplate>

module Corrections =
    let attrNameCorrections =
        [
            "class", "className"
            "type", "type'"
            "as", "as'"
            "default", "default'"
            "for", "for'"
            "open", "open'"
            "http-equiv", "httpEquiv"
            "moz-opaque", "mozOpaque"
            "accept-charset", "acceptCharset"
        ]

    let attrExcludes =
        [
            "data-*"
        ]
        
    let elemNameCorrections =
        [
            "base", "base'"
        ]

    let additionalElemAttrs =
        let makeAttr (elemName: string) name typ =
            elemName,
            {
                name = name
                isDeprecated = false
                isNonStandard = false
                desc = ""
                typ = typ
                felizAttr = None
            }
        [
            makeAttr "input" "type" (AttrTyp.Dotnet typeof<string>)
        ]
        |> List.groupBy fst
        |> List.map (fun (k,v) -> k, v |> List.map snd)
        |> Map.ofList

    let elemExcludes =
        [
            "base"
            "data"
            "time"
            "picture"
            "meter"
            "output"
            "details"
            "dialog"
            "slot"
            "template"
            "portal"
        ]

    let globalEvents =
        [
            "onabort"
            //"onautocomplete"
            //"onautocompleteerror"
            "onblur"
            //"oncancel"
            "oncanplay"
            "oncanplaythrough"
            "onchange"
            "onclick"
            //"onclose"
            "oncontextmenu"
            "oncuechange"
            "ondblclick"
            "ondrag"
            "ondragend"
            "ondragenter"
            "ondragleave"
            "ondragover"
            "ondragstart"
            "ondrop"
            "ondurationchange"
            "onemptied"
            "onended"
            "onerror"
            "onfocus"
            "oninput"
            //"oninvalid"
            "onkeydown"
            "onkeypress"
            "onkeyup"
            "onload"
            "onloadeddata"
            "onloadedmetadata"
            "onloadstart"
            "onmousedown"
            "onmouseenter"
            "onmouseleave"
            "onmousemove"
            "onmouseout"
            "onmouseover"
            "onmouseup"
            "onmousewheel"
            "onpause"
            "onplay"
            "onplaying"
            "onprogress"
            "onratechange"
            "onreset"
            //"onresize"
            "onscroll"
            "onseeked"
            "onseeking"
            "onselect"
            //"onshow"
            //"onsort"
            "onstalled"
            "onsubmit"
            "onsuspend"
            "ontimeupdate"
            //"ontoggle"
            "onvolumechange"
            "onwaiting"
        ]

let htmlGlobalAttrsElementBuilderName = "HTMLGlobalAttrsElementBuilder"

let generate (elements: Element list) (globalAttrs: Attr list) = 
    let correctWith altNames name =
        altNames 
        |> List.tryFind (fun x -> fst x = name)
        |> Option.map snd
        |> Option.defaultValue name

    let makeAttr (attr: Attr) =
        let memberName = attr.name |> correctWith Corrections.attrNameCorrections
        let typ,toString =
            match attr.typ with
            | AttrTyp.Dotnet typ ->
                let toString =
                    match typ with
                    | t when t = typeof<string> -> ""
                    | _ -> ".ToString()"
                typ.FullName, toString
            | AttrTyp.Enum labels -> "string", ""
            | AttrTyp.Choice labels -> "string", ""
        Api.attr(memberName,attr.name, toString, typ)

    let makeAttrs (attrs: Attr list)=
        attrs
        |> List.distinctBy (fun a -> a.name)
        |> List.map makeAttr
        |> List.sortBy (fun x -> x.name)
        |> List.filter (fun attr -> Corrections.attrExcludes |> List.contains attr.name |> not)

    let globalElem =
        let ctorParams = "tagName"
        Api.elem(
            globalAttrs |> makeAttrs,
            htmlGlobalAttrsElementBuilderName,
            ctorParams,
            ctorParams,
            Corrections.globalEvents |> List.map Api.evt,
            htmlGlobalAttrsElementBuilderName,
            true,
            "'n",
            "HTMLElementBuilder",
            false,
            "<'n when 'n :> HTMLElement>"
        )

    let makeElem (elem: Element) =
        let events = [] //Corrections.globalEvents |> List.map Api.evt
        let attrs =
            (
                elem.attrs.attrs
                @ (Corrections.additionalElemAttrs |> Map.tryFind elem.name |> Option.defaultValue [])
            )
            |> makeAttrs
        let fsharpTageName = elem.name |> correctWith Corrections.elemNameCorrections
        let inheritorName = 
            if elem.attrs.includeGlobalAttrs 
            then htmlGlobalAttrsElementBuilderName
            else "HTMLElementBuilder"
        let tagName = $""" "{elem.name}" """
        Api.elem(
            attrs,
            fsharpTageName,
            tagName,
            "",
            events, 
            fsharpTageName,
            false,
            elem.domInterfaceName,
            inheritorName,
            true,
            ""
        )

    let elems =
        globalElem
        :: (
            elements
            |> List.filter (fun e -> Corrections.elemExcludes |> List.contains e.name |> not)
            |> List.map makeElem
        )
        |> List.sortBy (fun x -> x.fsharpTageName)

    let root = Api.Root(elems)

    Api.Render(root)
